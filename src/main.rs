use aws_config::meta::region::RegionProviderChain;
use aws_lambda_events::event::cloudwatch_logs::LogsEvent;
use aws_sdk_secretsmanager;
use aws_sdk_sns;
use headers::authorization::Basic;
use headers::{Authorization, HeaderMapExt};
use hyper::{Body, Method, Request};
use hyper_tls::HttpsConnector;
use lambda_runtime::{run, service_fn, Error, LambdaEvent};
use serde_json::{json, Value};

async fn create_jira_issue(
    basic: Authorization<Basic>,
    name: &str,
    version: &str,
    branch: &str,
) -> Result<String, Box<dyn std::error::Error + Send + Sync>> {
    let body = Body::from(
        json!({
          "fields": {
            "summary": format!("Release {} {}", name, version),
            "description": {
              "type": "doc",
              "version": 1,
              "content": [
                {
                  "type": "paragraph",
                  "content": [
                    {
                      "text": "Generated by image builder!",
                      "type": "text"
                    }
                  ]
                }
              ]
            },
            std::env::var("JIRA_NAME_FIELD").unwrap(): name,
            std::env::var("JIRA_VERSION_FIELD").unwrap(): version,
            "issuetype": {
              "id": std::env::var("JIRA_ISSUE_TYPE").unwrap()
            },
            "project": {
              "key": format!("{}{}", std::env::var("JIRA_PROJECT_KEY_PREFIX").unwrap(), branch)
            }
          }
        })
        .to_string(),
    );

    let mut request = Request::builder()
        .method(Method::POST)
        .uri(format!(
            "{}{}",
            std::env::var("JIRA_BASE_URL").unwrap(),
            "/rest/api/3/issue"
        ))
        .header("content-type", "application/json")
        .body(body)?;

    let headers = request.headers_mut();
    headers.typed_insert(basic);

    let https = HttpsConnector::new();

    let client = hyper::Client::builder().build::<_, hyper::Body>(https);

    let response = client.request(request).await?;

    let body_bytes = hyper::body::to_bytes(response.into_body()).await?;

    let v: Value = serde_json::from_slice(&body_bytes).unwrap();

    Ok(format!(
        "{}/browse/{}",
        std::env::var("JIRA_BASE_URL").unwrap(),
        v["key"].as_str().unwrap()
    ))
}

/// This is the main body for the function.
/// Write your code inside it.
/// There are some code example in the following URLs:
/// - https://github.com/awslabs/aws-lambda-rust-runtime/tree/main/examples
/// - https://github.com/aws-samples/serverless-rust-demo/
async fn function_handler(event: LambdaEvent<LogsEvent>) -> Result<(), Error> {
    // Extract some useful information from the request

    let (event, _) = event.into_parts();

    let data = event.aws_logs.data;

    let region_provider = RegionProviderChain::default_provider().or_else("us-east-1");

    let config = aws_config::from_env().region(region_provider).load().await;

    let client = aws_sdk_secretsmanager::Client::new(&config);

    let response = client
        .get_secret_value()
        .secret_id(std::env::var("JIRA_PW_SECRET_ID").unwrap())
        .send()
        .await?;

    let basic = Authorization::basic(
        &std::env::var("JIRA_USERNAME").unwrap(),
        &response.secret_string.unwrap(),
    );

    let client = aws_sdk_sns::Client::new(&config);

    for e in data.log_events.iter() {
        let v: Value = serde_json::from_str(&e.message).unwrap();

        println!("{:?}", v);

        let arn = v["requestParameters"]["tagSpecificationSet"]["items"]
            .as_array()
            .unwrap()
            .iter()
            .filter(|x| x["resourceType"] == "image")
            .map(|x| &x["tags"])
            .next()
            .unwrap()
            .as_array()
            .unwrap()
            .iter()
            .filter(|x| x["key"] == "Ec2ImageBuilderArn")
            .map(|x| &x["value"])
            .next()
            .unwrap()
            .as_str()
            .unwrap();

        let a: Vec<&str> = arn.split("/").collect();

        let url = format!(
            "{}{}/log-events/{}$252F{}",
            std::env::var("CLOUDWATCH_BASE_URL").unwrap(),
            a[1],
            a[2],
            a[3]
        );

        let version = format!("{}/{}", a[2], a[3]);
        let branch = match &a[1][14..] {
            "dev" => Some("DEV"),
            "pre-prod" => Some("PP"),
            "pre-prod-2" => Some("PP2"),
            "prod" => Some("PROD"),
            "staging" => Some("STG"),
            "uat1" => Some("UAT1"),
            "uat2" => Some("UAT2"),
            "uat3" => Some("UAT3"),
            _ => None,
        };

        let url2 = match branch {
            Some(b) => create_jira_issue(basic.clone(), &a[1], &version, &b).await?,
            _ => "".to_string(),
        };

        let subject = match &a[1][14..] {
            "base-image" => "New Base Image",
            "dev" => "New Dev Image",
            "pre-prod" => "New Pre-Prod Image",
            "pre-prod-2" => "New Pre-Prod-2 Image",
            "prod" => "New Prod Image",
            "staging" => "New Staging Image",
            "uat1" => "New UAT1 Image",
            "uat2" => "New UAT2 Image",
            "uat3" => "New UAT3 Image",
            _ => "New AMI",
        };

        let response = client
            .publish()
            .topic_arn(std::env::var("TOPIC_ARN").unwrap())
            .subject(subject)
            .message(format!(
                "Image builder pipeline: {}\nAmi id: {}\nBuild log: {}\nJira: {}",
                arn,
                v["responseElements"]["imageId"].as_str().unwrap(),
                url,
                url2
            ))
            .send()
            .await?;

        println!("{:?}", response);
    }

    Ok(())
}

#[tokio::main]
async fn main() -> Result<(), Error> {
    run(service_fn(function_handler)).await
}
